"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const filepath = require("path");
const filetypes_1 = require("./filetypes");
const policy_1 = require("./policy");
const types_1 = require("./types");
const isWindows = filepath.sep === "\\";
class LocalFiles {
    constructor(root, policy, config) {
        if (!root ||
            (!isWindows && root[0] !== "/") ||
            (isWindows && !/^[A-Z]:\\/i.test(root))) {
            // expect full path from the drive root
            // it is necessary to ensure ForceRoot policy
            throw new Error("Invalid root folder");
        }
        // /some/path/ => /some/path
        if (root[root.length - 1] === filepath.sep) {
            root = root.substr(0, root.length - 1);
        }
        // /root/some/../../other => /root/other
        this._root = filepath.normalize(root);
        if (!policy) {
            this.policy = new policy_1.ForceRootPolicy(this._root);
        }
        else {
            this.policy = new policy_1.CombinedPolicy(new policy_1.ForceRootPolicy(this._root), policy);
        }
        this._config = config || {};
    }
    list(path, config) {
        return __awaiter(this, void 0, void 0, function* () {
            config = config || {};
            if (this._config.verbose) {
                console.log("List %s", path);
                console.log("with config ", config);
            }
            const fullpath = this.idToPath(path);
            if (this.policy.comply(fullpath, types_1.Operation.Read)) {
                return this._listFolder(fullpath, path, config, null);
            }
            throw new Error("Access Denied");
        });
    }
    remove(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._config.verbose) {
                console.log("Delete %s", path);
            }
            const fullpath = this.idToPath(path);
            if (this.policy.comply(fullpath, types_1.Operation.Write)) {
                return fs.remove(fullpath);
            }
            throw new Error("Access Denied");
        });
    }
    read(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._config.verbose) {
                console.log("Get content of %s", path);
            }
            const fullpath = this.idToPath(path);
            if (this.policy.comply(fullpath, types_1.Operation.Read)) {
                return fs.createReadStream(fullpath);
            }
            throw new Error("Access Denied");
        });
    }
    write(path, data, config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._config.verbose) {
                console.log("Save content to %s", path);
            }
            let fullpath = this.idToPath(path);
            if (this.policy.comply(fullpath, types_1.Operation.Write)) {
                if (config && config.preventNameCollision) {
                    fullpath = yield this.checkName(fullpath, "file");
                }
                const writeStream = fs.createWriteStream(fullpath);
                const result = data.pipe(writeStream);
                const done = new Promise((res, rej) => {
                    data.on("end", res);
                    data.on("error", rej);
                });
                return done.then(() => this.pathToId(fullpath));
            }
            throw new Error("Access Denied");
        });
    }
    info(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const fullpath = this.idToPath(id);
            if (!this.policy.comply(fullpath, types_1.Operation.Read)) {
                throw new Error("Access Denied");
            }
            const stat = yield fs.lstat(fullpath);
            const name = filepath.basename(fullpath);
            const type = stat.isDirectory() ? "folder" : filetypes_1.default(name);
            const obj = {
                value: name,
                id,
                size: stat.size,
                date: stat.mtime.valueOf() / 1000,
                type
            };
            return obj;
        });
    }
    mkdir(path, config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._config.verbose) {
                console.log("Make folder %s", path);
            }
            let fullpath = this.idToPath(path);
            if (!this.policy.comply(fullpath, types_1.Operation.Write)) {
                throw new Error("Access Denied");
            }
            if (config && config.preventNameCollision) {
                fullpath = yield this.checkName(fullpath, "folder");
            }
            yield fs.ensureDir(fullpath);
            return this.pathToId(fullpath);
        });
    }
    copy(sourceId, targetId, config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._config.verbose) {
                console.log("Copy %s to %s", sourceId, targetId);
            }
            const source = this.idToPath(sourceId);
            let target = this.idToPath(targetId);
            if (!this.policy.comply(source, types_1.Operation.Read) || !this.policy.comply(target, types_1.Operation.Write)) {
                throw new Error("Access Denied");
            }
            const et = yield this.isFolder(target);
            // file to folder
            if (et) {
                target = filepath.join(target, filepath.basename(source));
            }
            if (config && config.preventNameCollision) {
                const stat = yield fs.lstat(source);
                const type = stat.isDirectory() ? "folder" : "file";
                target = yield this.checkName(target, type);
            }
            // file to file
            yield fs.copy(source, target);
            return this.pathToId(target);
        });
    }
    exists(source) {
        return __awaiter(this, void 0, void 0, function* () {
            source = this.idToPath(source);
            if (this.policy.comply(source, types_1.Operation.Read)) {
                return fs.pathExists(source);
            }
            throw new Error("Access Denied");
        });
    }
    move(source, target, config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._config.verbose) {
                console.log("Move %s to %s", source, target);
            }
            source = this.idToPath(source);
            target = this.idToPath(target);
            if (!this.policy.comply(source, types_1.Operation.Write) ||
                !this.policy.comply(target, types_1.Operation.Write)) {
                throw new Error("Access Denied");
            }
            const et = yield this.isFolder(target);
            // file to folder
            if (et) {
                target = filepath.join(target, filepath.basename(source));
            }
            if (config && config.preventNameCollision) {
                const stat = yield fs.lstat(source);
                const type = stat.isDirectory() ? "folder" : "file";
                target = yield this.checkName(target, type);
            }
            yield fs.move(source, target);
            return this.pathToId(target);
        });
    }
    isFolder(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const stat = yield fs.lstat(path);
                return stat.isDirectory();
            }
            catch (e) {
                return false;
            }
        });
    }
    idToPath(id) {
        return filepath.normalize(filepath.join(this._root, id));
    }
    pathToId(path) {
        const id = path.replace(this._root, "");
        if (isWindows) {
            return id.replace(/\\/g, "/");
        }
        return id;
    }
    _listFolder(path, prefix, cfg, list) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = yield fs.readdir(path);
            const res = (list && !cfg.nested) ? list : [];
            for (const name of files) {
                if (name === ".") {
                    continue;
                }
                if (cfg.exclude && cfg.exclude(name)) {
                    continue;
                }
                const fullpath = filepath.join(this._root, prefix, name);
                const id = this.pathToId(fullpath);
                const stat = yield fs.lstat(fullpath);
                const type = stat.isDirectory() ? "folder" : filetypes_1.default(name);
                const obj = { value: name, id, size: stat.size, date: stat.mtime.valueOf() / 1000, type };
                if (stat.isDirectory()) {
                    if (cfg.subFolders) {
                        const next = yield this._listFolder(filepath.join(path, name), filepath.join(prefix, name), cfg, res);
                        if (cfg.nested) {
                            obj.data = next;
                        }
                    }
                }
                else {
                    if (cfg.skipFiles) {
                        continue;
                    }
                }
                if (cfg.include && !cfg.include(name)) {
                    continue;
                }
                res.push(obj);
            }
            // folders first
            // sort files and folders by name
            if (list !== res) {
                res.sort((a, b) => {
                    if ((a.type === "folder" || b.type === "folder") && a.type !== b.type) {
                        return a.type === "folder" ? -1 : 1;
                    }
                    if (a.value !== b.value) {
                        return a.value.toUpperCase() > b.value.toUpperCase() ? 1 : -1;
                    }
                    return 0;
                });
            }
            return res;
        });
    }
    getNewName(name, counter, type) {
        // filepath.extname grabs the characters after the last dot (app.css.gz return .gz, not .css.gz)
        const ext = type === "file" ? name.substring(name.indexOf(".")) : "";
        name = filepath.basename(name, ext);
        const match = name.match(/\(([0-9]*)\)$/);
        if (match) {
            name = name.substr(0, match.index);
            counter = Number(match[1]) + 1;
        }
        return name + "(" + counter + ")" + ext;
    }
    checkName(path, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const folder = filepath.dirname(path);
            let name = filepath.basename(path);
            const files = yield fs.readdir(folder);
            let counter = 1;
            while (files.indexOf(name) !== -1) {
                name = this.getNewName(name, counter++, type);
            }
            return filepath.join(folder, name);
        });
    }
}
exports.default = LocalFiles;
//# sourceMappingURL=LocalFiles.js.map